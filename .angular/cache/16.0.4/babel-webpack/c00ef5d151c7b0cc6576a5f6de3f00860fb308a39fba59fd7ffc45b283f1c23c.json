{"ast":null,"code":"export class CacheStore {\n  constructor(maxCachedItems, expirationSecondsForItem) {\n    this.cacheDictionary = new KeyedCollection();\n    this.maxCachedItems = 0;\n    this.expirationSecondsForItem = 0;\n    this.maxCachedItems = maxCachedItems;\n    this.expirationSecondsForItem = expirationSecondsForItem;\n    console.log('CacheStore: initialized. maxCachedItems=' + this.maxCachedItems + ', expirationSecondsForItem=' + this.expirationSecondsForItem);\n  }\n  GetOrCache(key, func, doneFunc) {\n    console.log('CacheStore: keys in cache=' + this.cacheDictionary.Keys().join(','));\n    const keyExist = this.cacheDictionary.ContainsKey(key);\n    let isCacheExpired = false;\n    let cacheItem;\n    if (keyExist) {\n      cacheItem = this.cacheDictionary.Item(key);\n      const cachedSeconds = Math.abs((new Date().getTime() - cacheItem.time.getTime()) / 1000);\n      if (cachedSeconds > this.expirationSecondsForItem) {\n        console.log('CacheStore: item=' + key + ' was cached for ' + cachedSeconds + ' (expiretime=' + this.expirationSecondsForItem + ')');\n        isCacheExpired = true;\n      }\n    }\n    if (!keyExist || isCacheExpired) {\n      // Cache the item\n      func(data => {\n        if (isCacheExpired) {\n          // Since cache expired for this key, first remove it.\n          console.log('CacheStore: item=' + key + ' removed from cache');\n          this.cacheDictionary.Remove(key);\n        }\n        // Before adding to cache, verify if reached max limit of cached items.\n        if (this.cacheDictionary.Count() >= this.maxCachedItems) {\n          const firstAdded = this.cacheDictionary.FirstAddedKey();\n          console.log('CacheStore: reached maxCachedItems, item=' + firstAdded + ' removed (first)');\n          this.cacheDictionary.Remove(firstAdded);\n          // This will retain a maxCachedItems.\n        }\n\n        const newCacheItem = new CacheItem(data);\n        this.cacheDictionary.Add(key, newCacheItem);\n        console.log('CacheStore: item=' + key + ' added to cache');\n        doneFunc(data);\n      });\n    } else {\n      // Simply retrieve the item.\n      console.log('CacheStore: item=' + key + ' retrieved from cache');\n      doneFunc(cacheItem.item);\n    }\n  }\n}\nexport class CacheItem {\n  constructor(t) {\n    this.t = t;\n    this.time = new Date();\n    this.item = t;\n  }\n}\nexport class KeyedCollection {\n  constructor() {\n    this.items = {};\n    this.count = 0;\n  }\n  ContainsKey(key) {\n    return this.items.hasOwnProperty(key);\n  }\n  Count() {\n    return this.count;\n  }\n  Add(key, value) {\n    if (!this.items.hasOwnProperty(key)) {\n      this.count++;\n    }\n    this.items[key] = value;\n  }\n  Remove(key) {\n    const val = this.items[key];\n    delete this.items[key];\n    this.count--;\n    return val;\n  }\n  Item(key) {\n    return this.items[key];\n  }\n  FirstAddedKey() {\n    const keys = this.Keys();\n    return keys[0];\n  }\n  Keys() {\n    const keySet = [];\n    for (const prop in this.items) {\n      if (this.items.hasOwnProperty(prop)) {\n        keySet.push(prop);\n      }\n    }\n    return keySet;\n  }\n  Values() {\n    const values = [];\n    for (const prop in this.items) {\n      if (this.items.hasOwnProperty(prop)) {\n        values.push(this.items[prop]);\n      }\n    }\n    return values;\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}